# HTTP

## HTTP

### HTTP发展

### HTTP请求

#### 简单请求

- Get

- HEAD

  - HEAD 请求头的内容与 GET 一致，但是返回不包括响应体，响应头可能包含了 `Content-Length` 字段，描述相同情况 Get 请求返回的大小

  - HEAD 请求可以被缓存，如果 HEAD 请求显示协商缓存失效，下次 GET 请求会直接重新请求资源

  - 可以用于下载大文件前获取文件大小

- OPTION

  - 用于获取后端支持的请求方式，响应头会包含一个 `Allow` 字段，表明支持的请求方式。`Allow: OPTION, GET, POST`

  - 用于 CORS 中的预检请求（处理跨域问题），检测实际请求是否可以被服务器接收

    - （复杂）请求中会包含 `Access-Control-Request-Methods`(告知服务器实际请求时用的），`Access-Control-Request-Headers`（告知服务器请求所携带的自定义部头部字段）

    - 服务器会返回响应包含 `Access-Control-Allow-Methods`（只用于CORS，返回允许的字段），`Access-Control-Allow-Headers`(返回允许自定义头部)

#### 复杂请求

- POST

- PUT

- DELETE

### HTTP状态码

#### 2XX

- 200： 请求成功（命中强缓存也返回200）

- 201：已创建，成功请求并创建了新资源

- 204：无内容，服务器处理成功，但未返回内容，未更新网页的情况，可保持正常显示
#### 3XX

- 301：永久移动，请求资源已经移动到新的 URI，返回信息包括新的 URI，浏览器会自动定向到新的 URL，之后请求应该使用新的 URI

- 302：临时移动，资源被临时移动类似301，之后请求使用原有的 URI

- 304：触发协商缓存时会返回304状态码。[协商缓存↓](#协商缓存)

#### 4XX

- 400：请求语法错误，服务器无法理解

- 401：无权限，需要用户确认身份

- 403：服务器理解请求，但拒绝执行

- 404：服务器无法找到请求的资源

#### 5XX

- 500：服务器内部错误，无法完成请求

### HTTP缓存

HTTP 缓存是指当客户端向服务端请求资源的时候，会先抵达 **浏览器缓存**，如果浏览器缓存有该请求资源的副本，就可以直接从浏览器缓存中提取，不需要再请求服务器。

> 常见的 HTTP 缓存只能缓存 `Get` 请求，HTTP缓存都是从第二次请求开始的。

<img src="/基础/网络/HTTP缓存.jpeg" style="width: 70%; border: 1px solid black;" />

#### 强缓存

强缓存数据未失效的时候，会直接使用浏览器的缓存数据，**不会**向服务器发起请求。强缓存生效的时候服务器返回 `200` 状态码，页面加载最快。

未失效情况：

1. `Cache-Control` 的 `max-age` 未过期

2. `Expires` 的缓存时间未过期

|字段|属性|描述|
|:--|:--|:--|
| `Pragma` | `no-cache`: 不直接使用缓存，兼容 http/1.0 | HTTP/1.0 优先级大于 `Cache-Control` |
| `Cache-Control` | `no-cache`: 跳过强缓存直接走协商缓存 <br>`no-store`: 不适用缓存，每次都请求下载新资源 <br> `max-age`: 缓存时长 <br> `public / private`: 是否是能被单个用户使用 (public 客户端/代理服务器都可缓存，private: 服务可可缓存) <br> `must-revalidate`: 每次访问需要验证缓存 | HTTP/1.1 |
| `Expires` | GMT时间 | 使用 HTTP1.0 和 1.1 在缓存失效前获取不到修改后的资源，客户端和服务端时间不一致会出现问题  |

#### 协商缓存

触发协商缓存（与服务端协商对比资源是否发生了修改）

1. 第一次请求时候，请求头内无 `Cache-Control`、`Expires` 字段

2. 未命中强缓存 `Cache-Control` 或 `Expires` 过期

| <div style="width: 90pt">响应头字段</div> | <div style="width: 110pt">请求头字段</div> | 描述 |
|:--|:--|:--|
| `ETag` | `If-Not-Match` | (HTTP1.1) 参数为校验值，优先级高，默认使用hash算法，可以识别一秒内的修改，计算`ETag`有性能消耗 |
| `Last-Modified` | `If-Modified-Since` | (HTTP1.0)参数为GMT时间，精度为秒，优先级低，只要资源修改了，无论内容有无变化都会返回资源给客户端，以时间为标识，无法获取一秒内的修改，某些服务器不能准确获取最后的修改时间。 |

<font color="#f40">协商缓存流程</font>

1. 当浏览器第一次向服务器发送请求时，会在**响应头**中返回协商缓存的`header`属性`Etag`和`Last-Modified`，其中`ETag`为一个hash值，`Last-Modified`是GMT格式的最后修改时间。

2. 当浏览器第二次向服务器发送请求时，会在**请求头**上带上与`ETag`对应的`If-None-Match`,其值就是响应头中返回的`Etag`的hash值，`Last-Modified`对应的`If-Modified-Since`就是响应头返回的`Last-Modified`值，服务器收到这两个参数后会进行比较，如果返回的304则说明资源未被

> `Etag` / `If-Not-Match`是在HTTP1.1出现的，解决以下问题

- Last-Modifed精确到秒级，如果1秒被修改多次，则不能准确标注这多次的变化

- 如果某些文件被修改了，但是内容没变化，而`Last-Modified`却改变了，导致文件无法使用缓存

- 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致的情况

#### 浏览器缓存位置

chrome 开发者工具 network -> size

有文件大小的则是网络请求否则会列出以下1/2/3的情况

读取优先级

1. Service Worker: 不通过浏览器操作，可以自行操作（额外的缓存位置，永久保存，除非调用API删除，或缓存已满）

2. form memory cache: 从内存读取（读写快，存放更新频率高的资源，几乎所有请求资源都会进入该缓存，一般tab关闭后就清除，或者某个tab缓存资源很多时候前面的缓存就清除了）

3. from disk cache: 从磁盘读取（读写慢，存放更新频率低的）

4. 网络请求

#### 触发缓存

1. 打开网页输入地址: 查找 disk cache, 有则使用，否则请求
2. F5刷新: 因为tab未关闭，所以先查看memory cache 其次 disk cache
3. Ctrl + F5 强制刷新: 不用缓存，`Cache-control: no-cahche`,为了兼容还会带上`Pragam: no-cache`

### 长/短连接、KeepAlive

## HTTPS

### HTTP与HTTPS区别

HTTPS 在 HTTP 的基础上加上了 **SSL** 协议，**SSL** 协议通过证书来验证服务器身份，并为浏览器和服务器之间通信加密（传输层）

> HTTP + 保密性 + 身份校验认证 + 完整性保护 = HTTPS

1. HTTP 协议需要 CA 申请证书或自制证书

2. HTTP是直接与TCP进行传输，使用**明文传输**，80端口。HTTPS运行在 SSL/TSL(安全传输协议)之上，使用 **SSL 加密传输**，而 SSL/TSL 运行在 TCP 之上，使用443端口。

> SSL/TLS基本工作的方式：客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的秘钥，然后对称加密算法使用协商秘钥对信息以及信息摘要进行加密通信，不同结点之间采用对称秘钥不同，保证信息智能通信双方获取。

### HTTPS加密原理

#### 对称加密&非对称加密

- 对称加密：通过一个秘钥可以对消息进行加密/解密

- 非对称加密：一个公钥和一个私钥，公钥可以解密私钥加密的内容，私钥可以解密公钥加密的内容。

#### 数字签名制作

1. CA机构拥有非对称加密的公钥和私钥

2. CA机构对证书明文数据T进行hash生成hash值

3. 对hash值使用私钥加密得到数字签名S

4. 明文数据T加上数字签名S组成数字证书颁发给网站

#### 浏览器验证签名

1. HTTP发起请求，服务器传递数字证书（包含明文T个数字签名S）。

2. 拿到证书获取到证书的明文T，签名S

3. 用CA机构的公钥对S进行解密得到S1

4. 用证书里指明的hash算法对明文T进行hash得到T1

5. 判断T1 === S1即可

#### 为何安全

- 明文数据包含了网站的信息，通过hash加密后生成的数字签名S是确定的

- 客户端拿到证书后，通过CA机构公钥解密出来的hash值是CA机构对明文hash产生的hash值。客户端自己通过证书的hash算法生成的hash值应该与CA机构hash产生的hash值相等才可以。

- 如果中间人篡改了证书的原文，那么客户端hash产生的hash值会与CA机构hash的hash值不同，就可确认被篡改。

- 证书也不可能被掉包，因为如果劫持了证书换成自己的证书，那么客户端只需要检测一下证书明文里的包含的网站信息是否复合请求的网站即可。

:::tip 明文为什么要hash后再加密
非对称加密比较耗时，hash后可以得到固定长度的信息。可以降低加密所消耗的时间，而且也有一定程度安全考虑。
:::

### 中间人攻击

中间人攻击分为 SSL劫持攻击、SSL剥离攻击。

中间人攻击简单的理解：介入到客户端和服务端传输过程中间，分别伪装成客户端和服务端与双方进行数据传输，使得两端认为正在通过私密的连接对话。

![中间人攻击](/基础/网络/中间人攻击-简.jpeg)

#### SSL劫持

#### SSL剥离

