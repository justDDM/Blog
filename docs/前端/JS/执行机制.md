# 执行机制

## 执行上下文

### EC: 执行上下文

每当控制器运行到一段 **可执行代码** 的时候，会进入一个执行上下文

每一个执行上下文都关联一个**变量对象（VO:variable object）** 里面包含了这个上下文中定义的所有**变量**和**函数**，上下文在其所有代码执行完毕后会销毁。

- **可执行代码**

  - 全局代码：默认的代码环境，JS引擎最先进入的环境

  - 函数代码：执行一个函数，函数内部的代码

  - eval代码：`eval`函数内的代码

全局上下文是最外层的上下文（在浏览器中全局上下文为 `window` 对象）

- **变量对象 VO**

  - 类型

    - GO: 全局上下文变量对象

    - AO：当前活跃的上下文中的变量对象（函数上下文）
  
  - 当上下文为函数上下文时，变量对象最初会包含一个 `arguments` 变量（全局上下文无）

  - 参数

  - 内部变量

  - 函数声明

- 作用域链：上下文代码在执行的时候会创建变量对象的一个作用域链。

### ECS：执行上下文栈

> JS引擎始终执行 **栈顶** 的上下文

1. JS 引擎首先进入全局执行上下文，导致全局执行上下文在执行上下文栈的底部（栈底）

2. 当在全局上下文中调用函数则会进入函数的执行上下文，该函数执行上下文会被压入栈顶，执行过程遇到新的函数调用会压入新的执行上下文。

3. JS引擎会**优先执行栈顶**的上下文，当上下文代码执行完毕后，该上下文会被弹出执行栈并被销毁（包括定义在其上的函数和变量），回到上一个执行上下文继续执行。

:::tip Tip
1. 递归函数每次递归调用也都会创建一个新的执行上下文
2. 递归函数的`[[scope]]`只有一个
:::

### 执行过程

**进入执行上下文**

1. 确定形参（实参复制给形参对应变量名的变量，若未传递则赋值 `undefined`）、确定 `arguments` 的值

2. 函数声明：确定字面量声明的函数，将该变量指向函数对象（VO中有同名变量则覆盖）

3. 变量声明：先将函数内定义的变量（`var`声明的变量）赋值为 `undefined`，（真正赋值是需要等到赋值语句被执行时，若VO有同名变量则忽略）

**执行阶段**

正常按顺序执行代码

- example

```js
  console.log(a, b); // f a() {}, undefined
  var a = 1;
  var b = 2;
  console.log(a, b);  // 1, 2
  function a () {};
  var b = function() {};
  console.log(a, b);  // 1, f(){}
```

1. 进入执行上下文，未执行
   1. 函数声明：将a 的值设置为 a函数 ，（字面量声明函数后，该声明语句在执行阶段可忽略）
   2. 变量声明：b的值设为undfined
   3. 此时a的值为函数a，b的值为undefined
2. 执行阶段
   1. 输出a (值为函数a) 输出b（值为undefined）
   2. 将1赋值给a，将2赋值给b
   3. 输出a（值为1），输出b (值为2）
   4. 将匿名函数赋值给遍历b
   5. 输出a（值为1），输出b（值为匿名函数）

```js

  function test(a, b, c, d) {
    console.log(a, b, c, d); 
    // 10, 20, ƒ c() {}, undefined
    var a = 1;
    var b = function () {}
    function c() {}
    console.log(a, b, c, d);
    // 1, ƒ () {}, ƒ c() {} , undefined
  }
  test(10, 20, 30)
```
1. 进入函数执行上下文，未执行
   1. 确定形参的值，将AO内创建变量a,b,c,d。且a值设置为10，b的值设置为20, c的值为30,未传入的d为undefine（此时arguments内有传入实参的三个值,d没有实参不在arguments内）
   2. 函数声明：将c的值设置为c函数 覆盖原有的c（值为30的c）（字面量声明函数后，该声明语句在执行阶段可忽略）
   3. 变量声明：此时AO内已经存在有a,b的值，所以a不会设置为undefined,b也不会设置为函数对象
   4. 此时a的值为10，b的值为20，c的值为函数c，d的值为undefined
2. 函数执行阶段
   1. 输出a (值为函数10) 输出b（值为20），输出c（函数对象c）,输出d（undefined）
   2. 将1赋值给a，将匿名函数赋值给b
   3. 输出a（值为1），输出b (值为匿名函数），输出c(函数对象c)，输出d（undefined）

:::tip Tip
1. 即使变量在不会执行的代码块内定义（条件不成立的if，while等内）也同样会有变量提示，值为undefined而不会报错

2. IIFE函数若不为匿名函数，也不会出现在VO中
:::

## 事件循环

### 浏览器的事件循环

JS 是单线程的，所有任务需要排队执行，当一个任务执行时间很长时后续任务就需要等待，为了解决这个问题，将任务分为了 **同步任务** 和 **异步任务**。

同步任务在主线程上执行，会形成一个执行栈，异步任务在工作线程上执行，当异步任务完成后，会进入一个 **任务队列** 中进行排队，当主线程执行栈中的任务执行完毕后，主线程会读取任务队列里已经完成的异步任务开始执行，这个过程会一直循环，所以也称事件循环。

同步任务就是同步书写的代码，按顺序进行执行。

异步任务分为两种，一种是宏任务，一种是微任务。

- 宏任务：HTTP回调、用户事件、计时器等

- 微任务：Promise、MutationObserve

:::tip
`setTimeout` 第二个参数设为0 指的是最短触发的时间（最少也有4ms）因为需要等待同步任务以及微任务执行完毕才会执行，这个时间大于等于 4ms

JS 是单线程的，JS引擎只能维护一个主线程上的JS代码，但是浏览器环境是多线程的，可以进行网络请求、事件监听、计时器计时等，被称作工作线程。
:::

浏览器线程：

1. JS主线程：执行JS代码

2. GUI线程：渲染页面，与主线程互斥

3. HTTP线程：网络请求

4. 时间监听线程：监听用户事件

5. 计时器线程：计时器

### NodeJs 事件循环